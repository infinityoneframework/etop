defmodule Etop.Report do
  @moduledoc """
  ETOP Reporting Helpers.

  A set of functions to use to parse and process Etop results.

  Example output of :etop output

  ========================================================================================
   nonode@nohost                                                             14:21:44
   Load:  cpu         0               Memory:  total      120652    binary       8186
          procs     538                        processes   58065    code        28599
          runq        0                        atom         1498    ets          8615

  Pid            Name or Initial Func    Time    Reds  Memory    MsgQ Current Function
  ----------------------------------------------------------------------------------------
  <0.850.0>      'Elixir.InfinityOne.     '-'   32457   90772       0 gen_server:loop/7
  <0.992.0>      etop_txt:init/1          '-'   18534 1115108       0 etop:update/1
  <0.459.0>      erlang:apply/2           '-'   15943    5740       0 'Elixir.ExAmi.Reader
  <0.64.0>       group:server/3           '-'   1250414662300       0 group:server_loop/3
  <0.935.0>      'Elixir.UcxWallboard     '-'    1210  109380       0 gen_server:loop/7
  <0.954.0>      'Elixir.UcxWallboard     '-'    1192   75892       0 gen_server:loop/7
  <0.62.0>       user_drv                 '-'    1150   26612       0 user_drv:server_loop
  <0.934.0>      'Elixir.UcxWallboard     '-'    1118  142868       0 gen_server:loop/7
  <0.948.0>      'Elixir.UcxWallboard     '-'    1046   42404       0 gen_server:loop/7
  <0.615.0>      'Elixir.DBConnection     '-'     949   29716       0 gen_server:loop/7
  ========================================================================================
  """

  alias Etop.Utils
  require Logger
  require IEx

  @cols [15, 35, 8, 13, 9, 4, 10, 30]
  @header [
    "Pid",
    "Name or Initial Func",
    "Percent",
    "Reds",
    "Memory",
    "MssQ",
    "State",
    "Current Function"
  ]
  @report_width Enum.sum(@cols) + length(@cols)

  @header_str @header
              |> Enum.zip(@cols)
              |> Enum.with_index()
              |> Enum.map(fn {{str, cols}, i} ->
                case i do
                  0 -> String.pad_trailing(str, cols, " ")
                  7 -> str
                  _ -> String.pad_leading(str, cols, " ")
                end
              end)
              |> Enum.join(" ")
  @separator for _ <- 1..@report_width, do: "="
  @separator_dash for _ <- @separator, do: "-"

  @exs_template """
  defmodule Etop.Agent do
    @name __MODULE__
    def start do
      if Process.whereis(@name), do: stop()
      {:ok, _acc} = Agent.start(fn -> [] end, name: @name)
    end
    def add(item), do: Agent.cast(@name, & [item | &1])
    def stop, do: Agent.stop(@name)
    def get, do: @name |> Agent.get(& &1) |> Enum.reverse()
  end
  IO.puts "usage: data = Etop.Agent.get()"
  alias Etop.Agent, as: A
  {:ok, acc} = A.start()
  ## The following items as generated by Etop

  """

  @leader "  "
  @leader1 @leader <> @leader
  # @leader2 @leader <> @leader <> @leader

  @doc """
  Get the column with of the given column number.
  """
  def column_width(n), do: Enum.at(@cols, n)

  def get do
    if function_exported?(Etop.Agent, :get, 0), do: apply(Etop.Agent, :get, []), else: nil
  end

  @doc """
  Get the entry with the max load.

  Gets the entries from `Etop.Agent`
  """
  def max do
    with entries when is_list(entries) <- get(),
         do: max(entries)
  end

  @doc """
  Get the entry with the max load from the given entries list.
  """
  def max(entries) do
    max = Enum.max_by(entries, &get_in(&1, [:summary, :load, :cpu]))
    print(max)
    max
  end

  def load(path \\ "/tmp/etop.exs") do
    case Code.eval_file(path) do
      {:ok, _} -> get()
      error -> error
    end
  end

  def print(entry, file \\ nil)

  def print(entries, file) when is_list(entries) do
    Enum.each(entries, &print(&1, file))
  end

  def print(%{} = entry, file) do
    []
    |> puts(@separator)
    |> print_summary(entry)
    |> puts("")
    |> puts(@header_str)
    |> puts(@separator_dash)
    |> print_process(entry)
    |> Enum.reverse()
    |> write_report(file)
  end

  defp print_process(report, entry) do
    [l1, l2, l3, l4, l5, l6, l7, _l8] = @cols

    # IEx.pry()

    # IO.inspect(hd(entry.processes |> Enum.to_list()), label: "processes")

    entry.processes
    |> Enum.reduce(report, fn p, report ->
      try do
        puts(
          report,
          Enum.join(
            [
              pad_t(p.pid, l1),
              pad(p.name, l2),
              pad(p.percent, l3),
              pad(p.reds_diff, l4),
              pad(p.memory, l5),
              pad(p.msg_q, l6),
              pad(p.state, l7),
              p.fun
            ],
            " "
          )
        )
      rescue
        e ->
          IO.inspect(e)
          IO.inspect(p, label: "Bad result")
          report
      end
    end)
    |> puts(@separator)
    |> puts("")
  end

  defp print_summary(report, %{summary: summary}) do
    load = summary.load
    memory = summary.memory

    report
    |> puts(pad(summary.time, @report_width))
    |> summary_line(
      "Load:  cpu  ",
      load.cpu,
      "Memory:  total    ",
      memory.total,
      "     binary",
      memory.binary
    )
    |> summary_line(
      "       procs",
      load.nprocs,
      "processes",
      memory.processes,
      "     code",
      memory.code
    )
    |> summary_line(
      "       runq ",
      load.runq,
      "atom    ",
      memory.atom,
      "      ets",
      memory.ets
    )
  end

  defp puts(report, string) do
    ["\n", string | report]
  end

  def pad(string, len) when is_binary(string), do: String.pad_leading(string, len, " ")
  def pad(item, len), do: item |> to_string() |> pad(len)

  def pad_t(string, len) when is_binary(string), do: String.pad_trailing(string, len, " ")
  def pad_t(item, len), do: item |> to_string() |> pad_t(len)

  def save_eex_report(report, path) do
    exists? = File.exists?(path)

    File.open(path, [:append], fn fp ->
      unless exists?, do: IO.puts(fp, @exs_template)
      IO.puts(fp, "A.add(%{")
      IO.puts(fp, @leader <> "summary: " <> inspect(report.summary, pretty: true) <> ",")
      IO.puts(fp, @leader <> "processes: [")

      Enum.each(report.processes, fn item ->
        IO.puts(fp, @leader1 <> inspect(item, pretty: true) <> ",")
      end)

      IO.puts(fp, @leader <> "]")
      IO.puts(fp, "})\n##########\n")
    end)
  end

  defp summary_line(report, load_label, load, mem1_label, mem1, mem2_label, mem2) do
    puts(
      report,
      load_label <>
        pad(load, 7) <>
        pad(mem1_label, 40) <> pad(mem1, 15) <> pad_t(mem2_label, 11) <> pad(mem2, 10)
    )
  end

  def sort_by_load(entries, sorter \\ &>/2) do
    Enum.sort_by(entries, &get_in(&1, [:summary, :load, :cpu]), sorter)
  end

  def top(entries, num) do
    entries
    |> sort_by_load()
    |> Enum.take(num)
  end

  defp write_report(report, file) when is_binary(file) do
    case File.write(file, report, append: true) do
      :ok -> :ok
      error -> Logger.warn("Could not write to file #{file}, error: #{inspect(error)}")
    end
  end

  defp write_report(report, _) do
    IO.puts(report)
  end

  def list(entries, fields) when is_list(fields), do: Enum.map(entries, &get_in(&1, fields))

  def list(entries, scope, field), do: list(entries, [:summary, scope, field])

  def list_cpu(entries), do: list(entries, :load, :cpu)

  def list_memory(entries, field \\ :total), do: list(entries, :memory, field)

  def plot_cpu(entries, opts \\ []) do
    entries
    |> list_cpu()
    |> plot(Keyword.merge([label_prefix: "%"], opts))
  end

  def plot_memory(entries, opts \\ []) do
    field = opts[:field] || :total

    entries
    |> list(:memory, field)
    |> Enum.map(&(&1 / (1024 * 1024)))
    |> plot(Keyword.merge([width: 20, height: 100, label_prefix: "MB"], opts))
  end

  @empty_char 32
  def plot(items, opts \\ []) do
    height = opts[:height] || 20
    width = opts[:width] || 100
    label_prefix = opts[:label_prefix] || ""
    # def plot(items, height \\ 20, width \\ 100) do
    len = length(items) - 1

    # IO.inspect(Enum.map(items, &round/1), label: "items")

    max_y = items |> Enum.max() |> round()
    min_y = items |> Enum.min() |> round()

    scaler_y = if max_y <= height, do: 1, else: div(max_y - min_y + 1, height) + 1
    scaler_x = if len + 1 <= width, do: 1, else: div(len + 1, width) + 1

    orig_max_y = max_y
    orig_len = len
    orig_min_y = min_y

    max_y = div(max_y, scaler_y) + 1
    min_y = div(min_y, scaler_y)
    len = div(len, scaler_x) + 1

    leftover = for _ <- 1..scaler_x, do: 0

    scaled_items =
      items
      # chunk and average the x axis
      |> Enum.chunk_every(scaler_x, scaler_x, leftover)
      |> Enum.map(&Enum.max/1)
      # scale the y axis
      |> Enum.map(fn i ->
        round(i / scaler_y)
      end)
      |> Enum.map(&round/1)

    # |> IO.inspect(label: "scaled items")

    y_range = [0 | Enum.to_list(min_y..max_y)]
    x_range = 0..len

    # IO.inspect(%{
    #   min_y: min_y,
    #   max_y: max_y,
    #   len: len,
    #   orig_max_y: orig_max_y,
    #   orig_min_y: orig_min_y,
    #   orig_len: orig_len,
    #   width: width,
    #   height: height,
    #   scaler_x: scaler_x,
    #   scaler_y: scaler_y,
    #   x_range: x_range,
    #   y_range: y_range
    # })

    empty = for x <- x_range, y <- y_range, into: %{}, do: {{x, y}, @empty_char}

    grid =
      scaled_items
      |> Enum.with_index()
      |> Enum.reduce(empty, fn {num, i}, acc ->
        Map.put(acc, {i, num}, ?*)
      end)

    # IO.inspect(Enum.reject(grid, fn {pt, char} -> char == @empty_char end), label: "grid")

    leader = for _ <- 1..(String.length(label_prefix) + 5), do: 32
    x_axis = List.flatten(for _ <- x_range, do: [?-, ?-])
    # empty = for _ <- 1..20, do: [?-]
    x_axis =
      x_axis
      |> Enum.chunk_every(20, 20, [])
      |> Enum.map(fn [_ | list] ->
        IO.inspect(length(list), label: "len")
        char = if length(list) == 19, do: ?+, else: ?-
        list ++ [char]
      end)

    x_axis = [?+ | x_axis]

    add_leader = fn list -> list ++ leader ++ x_axis end

    x_count = div(Enum.count(x_range) * 2, 20)

    add_labels = fn list ->
      items = for i <- 1..x_count, do: pad(to_string(i * 10), 20)
      list ++ ["\n        " | items]
    end

    IO.inspect(x_count, label: "x_count")

    y_range
    |> Enum.reverse()
    |> Enum.map(fn i ->
      [
        pad(i * scaler_y, 4),
        label_prefix,
        " | " | Enum.map(x_range, &[grid[{&1, i}] || @empty_char, 32])
      ] ++
        ["\n"]
    end)
    |> add_leader.()
    |> add_labels.()
    |> IO.puts()

    # leader = for _ <- 1..(String.length(label_prefix) + 7), do: 32
    # IO.puts leader ++ x_axis
  end

  def create_report(list, total, stats) do
    stats
    |> create_summary()
    |> create_details(list, total)
  end

  defp create_details(report, list, total) do
    l2 = column_width(1)

    items =
      list
      |> Enum.reduce([], fn {pid, reds}, acc ->
        diff = reds.reductions_diff

        try do
          percent = to_string(Float.round(diff / total * 100, 2)) <> "%"

          # pid_str = pid |> inspect() |> String.trim_leading("#PID") |>

          item = %{
            pid: :erlang.pid_to_list(pid),
            name: name_or_initial_fun(reds, l2),
            percent: percent,
            reductions: reds.reductions,
            reds_diff: diff,
            memory: reds.memory,
            msg_q: reds.message_queue_len,
            state: reds.status,
            fun: format_fun(reds.current_function)
          }

          [item | acc]
        rescue
          e ->
            IO.inspect(e)
            IO.inspect(%{diff: diff, reds: reds, total: total}, label: "Bad result")
            acc
        end
      end)
      |> Enum.reverse()

    Map.put(report, :processes, items)
  end

  # nprocs = :process_count |> :erlang.system_info() |> to_string()
  # memory = Enum.into(:erlang.memory(), %{})
  # runq: statistics(:run_queue)
  defp create_summary(stats) do
    time = Utils.local_time() |> NaiveDateTime.to_time() |> to_string()
    cpu = if stats.load, do: stats.load.total, else: "-"

    %{
      summary: %{
        time: time,
        load: %{
          cpu: cpu,
          nprocs: stats.nprocs,
          runq: stats.runq
        },
        memory: stats.memory
      }
    }
  end

  defp name_or_initial_fun(reds, l2) do
    reds[:registerd_name]
    |> case do
      nil -> format_fun(dict_initial_call(reds) || reds[:initial_call])
      name when is_atom(name) -> name
    end
    |> to_string()
    |> String.replace(~r/^Elixir\./, "")
    |> String.slice(0, l2)
  end

  defp dict_initial_call(%{dictionary: dict}) when is_list(dict), do: dict[:"$initial_call"]
  defp dict_initial_call(_), do: nil

  def handle_report(state) do
    %{list: list, total: total, stats: stats} = state

    list
    |> create_report(total, stats)
    |> save_or_print(state)
  end

  defp save_or_print(report, %{format: :exs, file: path}) when is_binary(path),
    do: save_eex_report(report, path)

  defp save_or_print(report, %{file: path}),
    do: print(report, path)

  def format_fun({mod, fun, arity}), do: "#{inspect(mod)}.#{fun}/#{arity}"
  def format_fun(str) when is_binary(str), do: str
  def format_fun(_), do: ""
end
