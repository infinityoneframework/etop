defmodule Etop.Report do
  @moduledoc """
  ETOP Reporting Helpers.

  A set of functions to use to parse and process Etop results.

  Example output of :etop output

  ========================================================================================
   nonode@nohost                                                             14:21:44
   Load:  cpu         0               Memory:  total      120652    binary       8186
          procs     538                        processes   58065    code        28599
          runq        0                        atom         1498    ets          8615

  Pid            Name or Initial Func    Time    Reds  Memory    MsgQ Current Function
  ----------------------------------------------------------------------------------------
  <0.850.0>      'Elixir.InfinityOne.     '-'   32457   90772       0 gen_server:loop/7
  <0.992.0>      etop_txt:init/1          '-'   18534 1115108       0 etop:update/1
  <0.459.0>      erlang:apply/2           '-'   15943    5740       0 'Elixir.ExAmi.Reader
  <0.64.0>       group:server/3           '-'   1250414662300       0 group:server_loop/3
  <0.935.0>      'Elixir.UcxWallboard     '-'    1210  109380       0 gen_server:loop/7
  <0.954.0>      'Elixir.UcxWallboard     '-'    1192   75892       0 gen_server:loop/7
  <0.62.0>       user_drv                 '-'    1150   26612       0 user_drv:server_loop
  <0.934.0>      'Elixir.UcxWallboard     '-'    1118  142868       0 gen_server:loop/7
  <0.948.0>      'Elixir.UcxWallboard     '-'    1046   42404       0 gen_server:loop/7
  <0.615.0>      'Elixir.DBConnection     '-'     949   29716       0 gen_server:loop/7
  ========================================================================================
  """
  import Etop.Utils, only: [pad: 2, pad_t: 2]

  alias Etop.{Utils, Chart}

  require Logger
  require IEx

  @cols [15, 35, 8, 13, 9, 4, 10, 30]
  @header [
    "Pid",
    "Name or Initial Func",
    "Percent",
    "Reds",
    "Memory",
    "MssQ",
    "State",
    "Current Function"
  ]
  @report_width Enum.sum(@cols) + length(@cols)

  @header_str @header
              |> Enum.zip(@cols)
              |> Enum.with_index()
              |> Enum.map(fn {{str, cols}, i} ->
                case i do
                  0 -> String.pad_trailing(str, cols, " ")
                  7 -> str
                  _ -> String.pad_leading(str, cols, " ")
                end
              end)
              |> Enum.join(" ")
  @separator for _ <- 1..@report_width, do: "="
  @separator_dash for _ <- @separator, do: "-"

  @exs_template """
  defmodule Etop.Agent do
    @name __MODULE__
    def start do
      if Process.whereis(@name), do: stop()
      {:ok, _acc} = Agent.start(fn -> [] end, name: @name)
    end
    def add(item), do: Agent.cast(@name, & [item | &1])
    def stop, do: Agent.stop(@name)
    def get, do: @name |> Agent.get(& &1) |> Enum.reverse()
  end
  IO.puts "usage: data = Etop.Agent.get()"
  alias Etop.Agent, as: A
  {:ok, acc} = A.start()
  ## The following items as generated by Etop

  """

  @leader "  "
  @leader1 @leader <> @leader
  # @leader2 @leader <> @leader <> @leader

  @doc """
  Get the column with of the given column number.
  """
  def column_width(n), do: Enum.at(@cols, n)

  def get do
    if function_exported?(Etop.Agent, :get, 0), do: apply(Etop.Agent, :get, []), else: nil
  end

  @doc """
  Get the entry with the max load.

  Gets the entries from `Etop.Agent`
  """
  def max do
    with entries when is_list(entries) <- get(),
         do: max(entries)
  end

  @doc """
  Get the entry with the max load from the given entries list.
  """
  def max(entries) do
    max = Enum.max_by(entries, &get_in(&1, [:summary, :load, :cpu]))
    print(max)
    max
  end

  def load(path \\ "/tmp/etop.exs") do
    case Code.eval_file(path) do
      {:ok, _} -> get()
      error -> error
    end
  end

  def print(entry, file \\ nil)

  def print(entries, file) when is_list(entries) do
    Enum.each(entries, &print(&1, file))
  end

  def print(%{} = entry, file) do
    []
    |> puts(@separator)
    |> print_summary(entry)
    |> puts("")
    |> puts(@header_str)
    |> puts(@separator_dash)
    |> print_process(entry)
    |> Enum.reverse()
    |> write_report(file)
  end

  defp print_process(report, entry) do
    [l1, l2, l3, l4, l5, l6, l7, _l8] = @cols

    # IEx.pry()

    # IO.inspect(hd(entry.processes |> Enum.to_list()), label: "processes")

    entry.processes
    |> Enum.reduce(report, fn p, report ->
      try do
        puts(
          report,
          Enum.join(
            [
              pad_t(p.pid, l1),
              pad(p.name, l2),
              pad(p.percent, l3),
              pad(p.reds_diff, l4),
              pad(p.memory, l5),
              pad(p.msg_q, l6),
              pad(p.state, l7),
              p.fun
            ],
            " "
          )
        )
      rescue
        e ->
          IO.inspect(e)
          IO.inspect(p, label: "Bad result")
          report
      end
    end)
    |> puts(@separator)
    |> puts("")
  end

  defp print_summary(report, %{summary: summary}) do
    load = summary.load
    memory = summary.memory

    report
    |> puts(pad(summary.time, @report_width))
    |> summary_line(
      "Load:  cpu  ",
      load.cpu,
      "Memory:  total    ",
      memory.total,
      "     binary",
      memory.binary
    )
    |> summary_line(
      "       procs",
      load.nprocs,
      "processes",
      memory.processes,
      "     code",
      memory.code
    )
    |> summary_line(
      "       runq ",
      load.runq,
      "atom    ",
      memory.atom,
      "      ets",
      memory.ets
    )
  end

  defp puts(report, string) do
    ["\n", string | report]
  end

  def save_eex_report(report, path) do
    exists? = File.exists?(path)

    File.open(path, [:append], fn fp ->
      unless exists?, do: IO.puts(fp, @exs_template)
      IO.puts(fp, "A.add(%{")
      IO.puts(fp, @leader <> "summary: " <> inspect(report.summary, pretty: true) <> ",")
      IO.puts(fp, @leader <> "processes: [")

      Enum.each(report.processes, fn item ->
        IO.puts(fp, @leader1 <> inspect(item, pretty: true) <> ",")
      end)

      IO.puts(fp, @leader <> "]")
      IO.puts(fp, "})\n##########\n")
    end)
  end

  defp summary_line(report, load_label, load, mem1_label, mem1, mem2_label, mem2) do
    puts(
      report,
      load_label <>
        pad(load, 7) <>
        pad(mem1_label, 40) <> pad(mem1, 15) <> pad_t(mem2_label, 11) <> pad(mem2, 10)
    )
  end

  def sort_by_load(entries, sorter \\ &>/2) do
    Enum.sort_by(entries, &get_in(&1, [:summary, :load, :cpu]), sorter)
  end

  def top(entries, num) do
    entries
    |> sort_by_load()
    |> Enum.take(num)
  end

  defp write_report(report, file) when is_binary(file) do
    case File.write(file, report, append: true) do
      :ok -> :ok
      error -> Logger.warn("Could not write to file #{file}, error: #{inspect(error)}")
    end
  end

  defp write_report(report, _) do
    IO.puts(report)
  end

  def list(entries, fields) when is_list(fields), do: Enum.map(entries, &get_in(&1, fields))

  def list(entries, scope, field), do: list(entries, [:summary, scope, field])

  def list_cpu(entries), do: list(entries, :load, :cpu)

  def list_memory(entries, field \\ :total), do: list(entries, :memory, field)

  def plot_cpu(entries, opts \\ []) do
    labels = list(entries, [:summary, :time])

    entries
    |> list_cpu()
    |> plot(Keyword.merge([y_label_postfix: "%", title: "CPU Utilization", labels: labels], opts))
  end

  def plot_memory(entries, opts \\ []) do
    field = opts[:field] || :total

    labels = list(entries, [:summary, :time])

    entries
    |> list(:memory, field)
    |> Enum.map(&(&1 / (1024 * 1024)))
    |> plot(
      Keyword.merge(
        [width: 80, height: 50, y_label_postfix: "MB", title: "Memory Usage", labels: labels],
        opts
      )
    )
  end

  def plot(list, opts \\ []), do: Chart.puts(list, opts)

  def create_report(list, total, stats) do
    stats
    |> create_summary()
    |> create_details(list, total)
  end

  defp create_details(report, list, total) do
    l2 = column_width(1)

    items =
      list
      |> Enum.reduce([], fn {pid, reds}, acc ->
        diff = reds.reductions_diff

        try do
          percent = to_string(Float.round(diff / total * 100, 2)) <> "%"

          # pid_str = pid |> inspect() |> String.trim_leading("#PID") |>

          item = %{
            pid: :erlang.pid_to_list(pid),
            name: name_or_initial_fun(reds, l2),
            percent: percent,
            reductions: reds.reductions,
            reds_diff: diff,
            memory: reds.memory,
            msg_q: reds.message_queue_len,
            state: reds.status,
            fun: format_fun(reds.current_function)
          }

          [item | acc]
        rescue
          e ->
            IO.inspect(e)
            IO.inspect(%{diff: diff, reds: reds, total: total}, label: "Bad result")
            acc
        end
      end)
      |> Enum.reverse()

    Map.put(report, :processes, items)
  end

  # nprocs = :process_count |> :erlang.system_info() |> to_string()
  # memory = Enum.into(:erlang.memory(), %{})
  # runq: statistics(:run_queue)
  defp create_summary(stats) do
    time = Utils.local_time() |> NaiveDateTime.to_time() |> to_string()
    cpu = if stats.load, do: stats.load.total, else: "-"

    %{
      summary: %{
        time: time,
        load: %{
          cpu: cpu,
          nprocs: stats.nprocs,
          runq: stats.runq
        },
        memory: stats.memory
      }
    }
  end

  defp name_or_initial_fun(reds, l2) do
    reds[:registerd_name]
    |> case do
      nil -> format_fun(dict_initial_call(reds) || reds[:initial_call])
      name when is_atom(name) -> name
    end
    |> to_string()
    |> String.replace(~r/^Elixir\./, "")
    |> String.slice(0, l2)
  end

  defp dict_initial_call(%{dictionary: dict}) when is_list(dict), do: dict[:"$initial_call"]
  defp dict_initial_call(_), do: nil

  def handle_report(state) do
    %{list: list, total: total, stats: stats} = state

    list
    |> create_report(total, stats)
    |> save_or_print(state)
  end

  defp save_or_print(report, %{format: :exs, file: path}) when is_binary(path),
    do: save_eex_report(report, path)

  defp save_or_print(report, %{file: path}),
    do: print(report, path)

  def format_fun({mod, fun, arity}), do: "#{inspect(mod)}.#{fun}/#{arity}"
  def format_fun(str) when is_binary(str), do: str
  def format_fun(_), do: ""
end
