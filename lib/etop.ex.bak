defmodule Etop do
  @moduledoc """
  A Top like implementation for Elixir Applications.
  """
  use GenServer

  alias Etop.Report

  require Logger

  @name __MODULE__

  ###############
  # Public API

  def pause do
    GenServer.cast(@name, :pause)
  end

  @doc """
  Set Etop settings
  """
  def set_opts(opts) do
    if Enum.all?(Keyword.keys(opts), &(&1 in ~w(freq length debug file os_pid cores format)a)) do
      GenServer.cast(@name, {:set_opts, opts})
    else
      {:error, :invalid_opts}
    end
  end

  @doc """
  Start Etop Reporting.
  """
  def start(opts \\ []) do
    if Process.whereis(@name) do
      GenServer.cast(@name, :start)
    else
      GenServer.start(__MODULE__, opts, name: @name)
    end
  end

  @doc """
  Stop Etop Reporting.
  """
  def stop() do
    GenServer.cast(@name, :stop)
  end

  @doc """
  Get the status of the server
  """
  def status do
    GenServer.call(@name, :status)
  end

  def status! do
    GenServer.call(@name, :status!)
  end

  ######################
  # GenServer Callbacks

  def init(opts) do
    # Run the report in 1 second.
    Process.send_after(self(), :collect, 1000)

    if cpu_sup?(), do: :cpu_sup.start()

    os_pid = CpuUtil.getpid()
    cores = with {:ok, cores} <- CpuUtil.num_cores(), do: cores
    path = opts[:file]

    format =
      cond do
        val = opts[:format] -> val
        path && Path.extname(path) == ".exs" -> :exs
        true -> :text
      end

    {:ok,
     %{
       prev: nil,
       freq: opts[:freq] || 5000,
       length: opts[:length] || 10,
       debug: opts[:debug] || false,
       file: path,
       os_pid: os_pid,
       cores: cores,
       util: CpuUtil.pid_util(os_pid),
       load: nil,
       format: format,
       halted: Keyword.get(opts, :halted, false),
       timer_ref: nil
     }}
  end

  def handle_call(:status, _, state) do
    {:reply, Map.delete(state, :prev), state}
  end

  def handle_call(:status!, _, state) do
    {:reply, state, state}
  end

  def handle_call(:start, _, %{halted: true} = state) do
    {:reply, :ok, start_timer(%{state | halted: false}, 1000)}
  end

  def handle_call(:start, _, state) do
    {:reply, :not_halted, state}
  end

  def handle_call(:pause, _, %{halted: true} = state) do
    {:reply, :already_halted, state}
  end

  def handle_call(:pause, _, state) do
    {:reply, :ok, cancel_timer(%{state | halted: true})}
  end

  def handle_cast({:set_opts, opts}, state) do
    state = Enum.reduce(opts, state, fn {k, v}, state -> Map.put(state, k, v) end)
    {:noreply, state}
  end

  def handle_cast(:stop, state) do
    {:stop, :normal, state}
  end

  def handle_info(:collect, %{halted: true} = state) do
    {:noreply, state}
  end

  def handle_info(:collect, state) do
    {:noreply, state |> start_timer() |> handle_collect(system_info(:procs))}
  end

  def handle_info(:stop, state) do
    {:stop, :normal, state}
  end

  def handle_info(_, state) do
    # silently ignore unhandled info messages
    {:noreply, state}
  end

  def terminate(reason, state) do
    cancel_timer(state)
    IO.inspect(reason, label: "terminate")
    if cpu_sup?(), do: :cpu_sup.stop()
    :ok
  end

  ############
  # Helpers

  @doc """
  Handle the timer timeout.

  Collect and report the Top information.
  """
  def handle_collect(%{cores: cores, os_pid: os_pid, util: util1} = state, current) do
    util2 = CpuUtil.pid_util(os_pid)

    state = %{state | load: CpuUtil.calc_pid_util(util1, util2, cores)}

    curr = reductions_to_int(current)

    {current, total} = calc_reductions(curr, state.prev)

    current
    |> sort()
    |> Enum.take(state.length)
    |> handle_report(total, state)

    %{state | prev: curr, util: util2}
  end

  def statistics(item), do: :erlang.statistics(item)

  def system_info, do: system_info(:info)

  def system_info(which) do
    which
    |> :erlang.system_info()
    |> String.split("\n", trim: true)
    |> Enum.reduce({nil, nil, %{}}, fn
      "=" <> name, {nil, nil, acc} ->
        {name, %{}, acc}

      "=" <> name, {topic, map, acc} ->
        acc = Map.put(acc, topic, map)
        {name, %{}, acc}

      item, {topic, map, acc} ->
        map =
          case String.split(item, ":", parts: 2) do
            [name, value] ->
              Map.put(map, name, value)

            [one] ->
              Map.put(map, one, nil)
          end

        {topic, map, acc}
    end)
    |> add_last()
  end

  def handle_report(list, total, %{format: :exs, file: path} = state) when is_binary(path) do
    list
    |> create_report(total, state)
    |> Report.save_eex_report(path)
  end

  def handle_report(processes, total, state) do
    processes
    |> create_report(total, state)
    |> Report.print(state.file)
  end

  ##########
  # Private

  defp add_last({topic, map, acc}), do: Map.put(acc, topic, map)

  # defp calc_reductions(curr, nil) do
  #   {[], 0}
  # end

  @prev_default %{"Reductions" => 0}

  defp calc_reductions(curr, prev) do
    prev = if prev, do: prev, else: %{}

    Enum.reduce(curr, {[], 0}, fn {pid, settings}, {acc, total} ->
      with %{"Reductions" => reds2} <- prev[pid] || @prev_default,
           %{"Reductions" => reds1} <- settings do
        reds = reds1 - reds2
        {[{pid, Map.put(settings, "ReductionsDiff", reds)} | acc], total + reds}
      else
        _ -> {acc, total}
      end
    end)
  end

  defp cancel_timer(%{timer_ref: nil} = state), do: state

  defp cancel_timer(%{timer_ref: ref} = state) do
    Process.cancel_timer(ref)
    %{state | timer_ref: nil}
  end

  defp format_fun({mod, fun, arity}), do: "#{inspect(mod)}.#{fun}/#{arity}"
  defp format_fun(str) when is_binary(str), do: str
  defp format_fun(_), do: ""

  defp info(pid) do
    with true <- is_pid(pid),
         info when is_list(info) <- Process.info(pid) do
      initial_call =
        with dictionary when is_list(dictionary) <- info[:dictionary],
             {_, _, _} = mfa <- dictionary[:"$initial_call"] do
          format_fun(mfa)
        else
          _ -> nil
        end

      [
        name: info[:registered_name],
        current_function: info[:current_function],
        initial_call: initial_call
      ]
    else
      _ -> []
    end
  end

  defp name_or_initial_fun(reds, info, l2) do
    info[:name]
    |> case do
      nil -> info[:initial_call] || reds["Spawned as"]
      name when is_atom(name) -> name
    end
    |> to_string()
    |> String.replace(~r/^Elixir\./, "")
    |> String.slice(0, l2)
  end

  defp create_report(list, total, state) do
    state
    |> create_summary()
    |> create_details(list, total, state)
  end

  defp create_details(report, list, total, _state) do
    l2 = Report.column_width(1)

    items =
      list
      |> Enum.reduce([], fn {pid_str, reds}, acc ->
        diff = reds["ReductionsDiff"]

        try do
          percent = to_string(Float.round(diff / total * 100, 2)) <> "%"

          pid_str = String.replace(pid_str, "proc:", "")

          pid = pid_str |> String.to_charlist() |> :erlang.list_to_pid()

          info = info(pid)

          item = %{
            pid: pid_str,
            name: name_or_initial_fun(reds, info, l2),
            percent: percent,
            reductions: reds["Reductions"],
            reds_diff: diff,
            memory: String.trim(reds["Memory"]),
            msg_q: String.trim(reds["Message queue length"]),
            state: reds["State"] || "",
            fun: format_fun(info[:current_function])
          }

          [item | acc]
        rescue
          e ->
            IO.inspect(e)
            IO.inspect(%{diff: diff, reds: reds, total: total}, label: "Bad result")
            acc
        end
      end)
      |> Enum.reverse()

    Map.put(report, :processes, items)
  end

  defp create_summary(%{load: load}) do
    time = InfinityOne.Utils.local_time() |> NaiveDateTime.to_time() |> to_string()
    # cpu = if cpu_sup?(), do: :cpu_sup.util() |> Float.round(2) |> to_string(), else: loadavg()
    cpu = load.total
    nprocs = :process_count |> :erlang.system_info() |> to_string()
    memory = Enum.into(:erlang.memory(), %{})

    %{
      summary: %{
        time: time,
        load: %{
          cpu: cpu,
          nprocs: nprocs,
          runq: statistics(:run_queue)
        },
        memory: memory
      }
    }
  end

  defp reductions_to_int(raw) do
    Enum.reduce(raw, %{}, fn {pid, settings}, acc ->
      settings =
        Map.take(settings, ["Reductions", "Spawned as", "Memory", "State", "Message queue length"])

      with reds when is_binary(reds) <- settings["Reductions"],
           {num, _} <- reds |> String.trim() |> Integer.parse() do
        Map.put(acc, pid, Map.put(settings, "Reductions", num))
      else
        _ -> acc
      end
    end)
  end

  defp sort(
         curr,
         field \\ "ReductionsDiff",
         field_fn \\ fn field -> &elem(&1, 1)[field] end,
         sorter_fn \\ &>/2
       ) do
    Enum.sort_by(curr, field_fn.(field), sorter_fn)
  end

  defp cpu_sup? do
    if Application.get_env(:infinity_one, :etop_use_cpu_sup),
      do: function_exported?(:cpu_sup, :start, 0),
      else: false
  end

  defp start_timer(%{freq: interval} = state) do
    start_timer(state, interval)
  end

  defp start_timer(state, interval) when is_integer(interval) do
    %{state | timer_ref: Process.send_after(self(), :collect, interval)}
  end
end

defmodule CpuUtil do
  @moduledoc """
  CPU utility functions.

  Functions to read and calculate CPU utilization for a given process.

  NOTE: Only *nix systems supported.
  """

  @type proc_pid_stat :: %{
          # process id
          pid: integer(),
          # filename of the executable
          tcomm: binary(),
          # state (R is running, S is sleeping, D is sleeping in an
          # uninterruptible wait, Z is zombie, T is traced or stopped)
          state: binary(),
          # process id of the parent process
          ppid: integer(),
          # pgrp of the process
          pgrp: integer(),
          # session id
          sid: integer(),
          # tty the process uses
          tty_nr: integer(),
          # pgrp of the tty
          tty_pgrp: integer(),
          # task flags
          flags: integer(),
          # number of minor faults
          min_flt: integer(),
          # number of minor faults with child's
          cmin_flt: integer(),
          # number of major faults
          maj_flt: integer(),
          # number of major faults with child's
          cmaj_flt: integer(),
          # user mode jiffies
          utime: integer(),
          # kernel mode jiffies
          stime: integer(),
          # user mode jiffies with child's
          cutime: integer(),
          # kernel mode jiffies with child's
          cstime: integer()
        }

  @type util_stat :: %{
          total: integer(),
          stats: proc_pid_stat()
        }

  # list of fields returned when /proc/<PID>/stat is read.
  @proc_pid_stat_fields ~w[
    pid tcomm state ppid pgrp sid tty_nr tty_pgrp flags  min_flt
    cmin_flt maj_flt cmaj_flt utime  stime cutime cstime
  ]a

  @doc """
  Get the current OS PID
  """
  @spec getpid() :: integer()
  def getpid, do: List.to_integer(:os.getpid())

  @doc """
  Get the number of CPU Cores.
  """
  @spec num_cores() :: {:ok, integer()} | :error
  def num_cores do
    with topology <- :erlang.system_info(:cpu_topology),
         processors when is_list(processors) <- topology[:processor] do
      {:ok, length(processors)}
    else
      _ -> :error
    end
  end

  @doc """
  Read the CPU's average load.
  """
  @spec loadavg(integer()) :: binary()
  def loadavg(num \\ 1) do
    with {:ok, file} <- File.read("/proc/loadavg"),
         list <- String.split(file, ~r/\s/, trim: true) do
      list |> Enum.take(num) |> Enum.join(" ")
    else
      _ -> ""
    end
  end

  @doc """
  Read the OS stat data.

  * Reads `/proc/stat'
  * Pareses the first line ('cpu')
  * Converts the numbers (string) to integers
  """
  @spec stat() :: list() | {:error, any()}
  def stat do
    with {:ok, file} <- File.read("/proc/stat"),
         list <- String.split(file, "\n", trim: true),
         [cpu | _] <- list,
         [label | ints] <- String.split(cpu, ~r/\s/, trim: true),
         do: [label | Enum.map(ints, &String.to_integer/1)]
  end

  @doc """
  Get the total_time from the given list.

  Takes the output of CpuUtil.stat/0 and returns the total time.
  """
  @spec stat_total_time(list()) :: integer()
  def stat_total_time([_label | list]), do: Enum.sum(list)

  @doc """
  Get the total_time.

  Return the total time (from `/proc/stat`) as an integer.
  """
  @spec total_time() :: integer()
  def total_time do
    with [_ | _] = list <- stat(), do: stat_total_time(list)
  end

  @doc """
  Get the current OS <PID> stat.

  * Read `/proc/<PID>/stat` (single line of space separated fields)
  * Parse the fields and convert and numbers (string) to integers

  Returns a map of of the fields (atom keys) per the following definition:

  *  pid           process id
  *  tcomm         filename of the executable
  *  state         state (R is running, S is sleeping, D is sleeping in an
  *                uninterruptible wait, Z is zombie, T is traced or stopped)
  *  ppid          process id of the parent process
  *  pgrp          pgrp of the process
  *  sid           session id
  *  tty_nr        tty the process uses
  *  tty_pgrp      pgrp of the tty
  *  flags         task flags
  *  min_flt       number of minor faults
  *  cmin_flt      number of minor faults with child's
  *  maj_flt       number of major faults
  *  cmaj_flt      number of major faults with child's
  *  utime         user mode jiffies
  *  stime         kernel mode jiffies
  *  cutime        user mode jiffies with child's
  *  cstime        kernel mode jiffies with child's
  """
  @spec stat_pid(integer()) :: proc_pid_stat() | {:error, any()}
  def stat_pid(pid) do
    with {:ok, file} <- File.read("/proc/#{pid}/stat"),
         list <- String.split(file, ~r/\s/, trim: true),
         list <-
           Enum.map(list, fn item ->
             if item =~ ~r/^\d+$/, do: String.to_integer(item), else: item
           end),
         do: @proc_pid_stat_fields |> Enum.zip(list) |> Enum.into(%{})
  end

  @doc """
  Get the current OS stat.

  * Read the total time from `/proc/stat`
  * Read the PID stats from `/proc/<PID>/stat`

  Return a map:

      %{
        total: integer()
        stats: proc_pid_stat()
      }
  """
  @spec pid_util(integer) :: util_stat()
  def pid_util(pid),
    do: %{
      total: total_time(),
      stats: stat_pid(pid)
    }

  @doc """
  Calculate CPU utilization give 2 readings.

  ## Algorithm

  user_util = 100 * (utime_after - utime_before) / (time_total_after - time_total_before);
  sys_util = 100 * (stime_after - stime_before) / (time_total_after - time_total_before);

  ## Usage

      iex> pid = CpuUtil.os_pid()
      iex> cores = CpuUtil.num_cores()
      iex> u1 = CpuUtil.pid_util(pid)
      iex> Process.sleep(1000)
      iex> u2 = CpuUtil.pid_util(pid)
      iex> CpuUtil.calc_pid_util(u1, u2, cores)
      %{
         user: 2.0,
         sys: 0.5,
         total: 2.5
      }

  ## References

  * https://stackoverflow.com/questions/1420426/how-to-calculate-the-cpu-usage-of-a-process-by-pid-in-linux-from-c/1424556
  """
  def calc_pid_util(prev, curr, cores \\ 1, precission \\ 1) do
    try do
      t_diff = curr.total - prev.total

      user_util = 100 * (curr.stats.utime - prev.stats.utime) / t_diff * cores
      sys_util = 100 * (curr.stats.stime - prev.stats.stime) / t_diff * cores

      %{
        user: Float.round(user_util, precission),
        sys: Float.round(sys_util, precission),
        total: Float.round(user_util + sys_util, precission)
      }
    rescue
      e -> {:error, e}
    end
  end

  @doc """
  Get the cup_util for the given os_pid and number of cores.

  Blocks the calling process for time (1) seconds to collect the before and
  after samples.
  """
  def get_cpu_util(pid, cores \\ 1, time \\ 1) do
    util1 = pid_util(pid)
    Process.sleep(time * 1000)
    util2 = pid_util(pid)

    calc_pid_util(util1, util2, cores)
  end
end

defmodule Etop.Report do
  @moduledoc """
  ETOP Reporting Helpers.

  A set of functions to use to parse and process Etop results.

  Example output of :etop output

  ========================================================================================
   nonode@nohost                                                             14:21:44
   Load:  cpu         0               Memory:  total      120652    binary       8186
          procs     538                        processes   58065    code        28599
          runq        0                        atom         1498    ets          8615

  Pid            Name or Initial Func    Time    Reds  Memory    MsgQ Current Function
  ----------------------------------------------------------------------------------------
  <0.850.0>      'Elixir.InfinityOne.     '-'   32457   90772       0 gen_server:loop/7
  <0.992.0>      etop_txt:init/1          '-'   18534 1115108       0 etop:update/1
  <0.459.0>      erlang:apply/2           '-'   15943    5740       0 'Elixir.ExAmi.Reader
  <0.64.0>       group:server/3           '-'   1250414662300       0 group:server_loop/3
  <0.935.0>      'Elixir.UcxWallboard     '-'    1210  109380       0 gen_server:loop/7
  <0.954.0>      'Elixir.UcxWallboard     '-'    1192   75892       0 gen_server:loop/7
  <0.62.0>       user_drv                 '-'    1150   26612       0 user_drv:server_loop
  <0.934.0>      'Elixir.UcxWallboard     '-'    1118  142868       0 gen_server:loop/7
  <0.948.0>      'Elixir.UcxWallboard     '-'    1046   42404       0 gen_server:loop/7
  <0.615.0>      'Elixir.DBConnection     '-'     949   29716       0 gen_server:loop/7
  ========================================================================================
  """

  require Logger

  @cols [15, 35, 8, 13, 9, 4, 10, 30]
  @header [
    "Pid",
    "Name or Initial Func",
    "Percent",
    "Reds",
    "Memory",
    "MssQ",
    "State",
    "Current Function"
  ]
  @report_width Enum.sum(@cols) + length(@cols)

  @header_str @header
              |> Enum.zip(@cols)
              |> Enum.with_index()
              |> Enum.map(fn {{str, cols}, i} ->
                case i do
                  0 -> String.pad_trailing(str, cols, " ")
                  7 -> str
                  _ -> String.pad_leading(str, cols, " ")
                end
              end)
              |> Enum.join(" ")
  @separator for _ <- 1..@report_width, do: "="
  @separator_dash for _ <- @separator, do: "-"

  @exs_template """
  defmodule Etop.Agent do
    @name __MODULE__
    def start do
      if Process.whereis(@name), do: stop()
      {:ok, _acc} = Agent.start(fn -> [] end, name: @name)
    end
    def add(item), do: Agent.cast(@name, & [item | &1])
    def stop, do: Agent.stop(@name)
    def get, do: @name |> Agent.get(& &1) |> Enum.reverse()
  end
  IO.puts "usage: data = Etop.Agent.get()"
  alias Etop.Agent, as: A
  {:ok, acc} = A.start()
  ## The following items as generated by Etop

  """

  @leader "  "
  @leader1 @leader <> @leader
  # @leader2 @leader <> @leader <> @leader

  @doc """
  Get the column with of the given column number.
  """
  def column_width(n), do: Enum.at(@cols, n)

  def get do
    if function_exported?(Etop.Agent, :get, 0), do: apply(Etop.Agent, :get, []), else: nil
  end

  @doc """
  Get the entry with the max load.

  Gets the entries from `Etop.Agent`
  """
  def max do
    with entries when is_list(entries) <- get(),
         do: max(entries)
  end

  @doc """
  Get the entry with the max load from the given entries list.
  """
  def max(entries) do
    max = Enum.max_by(entries, &get_in(&1, [:summary, :load, :cpu]))
    print(max)
    max
  end

  def load(path \\ "/tmp/etop.exs") do
    case Code.eval_file(path) do
      {:ok, _} -> get()
      error -> error
    end
  end

  def print(entry, file \\ nil)

  def print(entries, file) when is_list(entries) do
    Enum.each(entries, &print(&1, file))
  end

  def print(%{} = entry, file) do
    []
    |> puts(@separator)
    |> print_summary(entry)
    |> puts("")
    |> puts(@header_str)
    |> puts(@separator_dash)
    |> print_process(entry)
    |> Enum.reverse()
    |> write_report(file)
  end

  defp print_process(report, entry) do
    [l1, l2, l3, l4, l5, l6, l7, _l8] = @cols

    entry.processes
    |> Enum.reduce(report, fn p, report ->
      try do
        puts(
          report,
          Enum.join(
            [
              pad_t(p.pid, l1),
              pad(p.name, l2),
              pad(p.percent, l3),
              pad(p.reds_diff, l4),
              pad(p.memory, l5),
              pad(p.msg_q, l6),
              pad(p.state, l7),
              p.fun
            ],
            " "
          )
        )
      rescue
        e ->
          IO.inspect(e)
          IO.inspect(p, label: "Bad result")
          report
      end
    end)
    |> puts(@separator)
    |> puts("")
  end

  defp print_summary(report, %{summary: summary}) do
    load = summary.load
    memory = summary.memory

    report
    |> puts(pad(summary.time, @report_width))
    |> summary_line(
      "Load:  cpu  ",
      load.cpu,
      "Memory:  total    ",
      memory.total,
      "     binary",
      memory.binary
    )
    |> summary_line(
      "       procs",
      load.nprocs,
      "processes",
      memory.processes,
      "     code",
      memory.code
    )
    |> summary_line(
      "       runq ",
      load.runq,
      "atom    ",
      memory.atom,
      "      ets",
      memory.ets
    )
  end

  defp puts(report, string) do
    ["\n", string | report]
  end

  def pad(string, len) when is_binary(string), do: String.pad_leading(string, len, " ")
  def pad(item, len), do: item |> to_string() |> pad(len)

  def pad_t(string, len) when is_binary(string), do: String.pad_trailing(string, len, " ")
  def pad_t(item, len), do: item |> to_string() |> pad_t(len)

  def save_eex_report(report, path) do
    exists? = File.exists?(path)

    File.open(path, [:append], fn fp ->
      unless exists?, do: IO.puts(fp, @exs_template)
      IO.puts(fp, "A.add(%{")
      IO.puts(fp, @leader <> "summary: " <> inspect(report.summary, pretty: true) <> ",")
      IO.puts(fp, @leader <> "processes: [")

      Enum.each(report.processes, fn item ->
        IO.puts(fp, @leader1 <> inspect(item, pretty: true) <> ",")
      end)

      IO.puts(fp, @leader <> "]")
      IO.puts(fp, "})\n##########\n")
    end)
  end

  defp summary_line(report, load_label, load, mem1_label, mem1, mem2_label, mem2) do
    puts(
      report,
      load_label <>
        pad(load, 7) <>
        pad(mem1_label, 40) <> pad(mem1, 15) <> pad_t(mem2_label, 11) <> pad(mem2, 10)
    )
  end

  def sort_by_load(entries, sorter \\ &>/2) do
    Enum.sort_by(entries, &get_in(&1, [:summary, :load, :cpu]), sorter)
  end

  def top(entries, num) do
    entries
    |> sort_by_load()
    |> Enum.take(num)
  end

  defp write_report(report, file) when is_binary(file) do
    case File.write(file, report, append: true) do
      :ok -> :ok
      error -> Logger.warn("Could not write to file #{file}, error: #{inspect(error)}")
    end
  end

  defp write_report(report, _) do
    IO.puts(report)
  end

  def list(entries, fields) when is_list(fields), do: Enum.map(entries, &get_in(&1, fields))

  def list(entries, scope, field), do: list(entries, [:summary, scope, field])

  def list_cpu(entries), do: list(entries, :load, :cpu)

  def list_memory(entries, field \\ :total), do: list(entries, :memory, field)

  def plot_cpu(entries, opts \\ []) do
    entries
    |> list_cpu()
    |> plot(Keyword.merge([label_prefix: "%"], opts))
  end

  def plot_memory(entries, opts \\ []) do
    field = opts[:field] || :total

    entries
    |> list(:memory, field)
    |> Enum.map(&(&1 / (1024 * 1024)))
    |> plot(Keyword.merge([width: 20, height: 100, label_prefix: "MB"], opts))
  end

  @empty_char 32
  def plot(items, opts \\ []) do
    height = opts[:height] || 20
    width = opts[:width] || 100
    label_prefix = opts[:label_prefix] || ""
    # def plot(items, height \\ 20, width \\ 100) do
    len = length(items) - 1

    # IO.inspect(Enum.map(items, &round/1), label: "items")

    max_y = items |> Enum.max() |> round()
    min_y = items |> Enum.min() |> round()

    scaler_y = if max_y <= height, do: 1, else: div(max_y - min_y + 1, height) + 1
    scaler_x = if len + 1 <= width, do: 1, else: div(len + 1, width) + 1

    orig_max_y = max_y
    orig_len = len
    orig_min_y = min_y

    max_y = div(max_y, scaler_y) + 1
    min_y = div(min_y, scaler_y)
    len = div(len, scaler_x) + 1

    leftover = for _ <- 1..scaler_x, do: 0

    scaled_items =
      items
      # chunk and average the x axis
      |> Enum.chunk_every(scaler_x, scaler_x, leftover)
      |> Enum.map(&Enum.max/1)
      # scale the y axis
      |> Enum.map(fn i ->
        round(i / scaler_y)
      end)
      |> Enum.map(&round/1)

    # |> IO.inspect(label: "scaled items")

    y_range = [0 | Enum.to_list(min_y..max_y)]
    x_range = 0..len

    # IO.inspect(%{
    #   min_y: min_y,
    #   max_y: max_y,
    #   len: len,
    #   orig_max_y: orig_max_y,
    #   orig_min_y: orig_min_y,
    #   orig_len: orig_len,
    #   width: width,
    #   height: height,
    #   scaler_x: scaler_x,
    #   scaler_y: scaler_y,
    #   x_range: x_range,
    #   y_range: y_range
    # })

    empty = for x <- x_range, y <- y_range, into: %{}, do: {{x, y}, @empty_char}

    grid =
      scaled_items
      |> Enum.with_index()
      |> Enum.reduce(empty, fn {num, i}, acc ->
        Map.put(acc, {i, num}, ?*)
      end)

    # IO.inspect(Enum.reject(grid, fn {pt, char} -> char == @empty_char end), label: "grid")

    y_range
    |> Enum.reverse()
    |> Enum.map(fn i ->
      [
        pad(i * scaler_y, 4),
        label_prefix,
        " | " | Enum.map(x_range, &[grid[{&1, i}] || @empty_char, 32])
      ] ++
        ["\n"]
    end)
    |> IO.puts()
  end
end
